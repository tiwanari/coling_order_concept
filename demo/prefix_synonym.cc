// -*- coding: utf-8 -*-
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <string>
#include <algorithm>
#include <sstream>
#include <tr1/unordered_map>
#define USE_REDUCED_TRIE
#include <cedar.h>

#ifdef USE_FCGI
#include <fcgi_stdio.h>
#endif

// static FILE* jdepp = 0;
// void sig_handler (int i) { if (jdepp) { pclose (jdepp); jdepp = 0; } }

static const size_t BUFFER_SIZE = 1 << 18;
static const size_t NUM_RESULT  = 1 << 24;
// these files are generated by using Wikipedia data
static const char*  DICT        = "/path/to/entities.count";
static const char*  HYPO        = "/path/to/hyper_hypo_count";

char* decode_query (char* sin, size_t lin = 0) {
  // URL decode
  if (! lin) lin = std::strlen (sin);

  char* p     = &sin[0];
  char* p_end = &sin[lin];
  char* q     = &sin[0];
  for(; p != p_end; ++p, ++q) {
    if (*p == '+') { *q = ' '; continue; }
    if (*p != '%') { *q = *p;  continue; }
    char tmp = (*++p >= 'A' ? *p - 'A' + 10 : *p - '0');
    tmp *= 16;
    tmp += (*++p >= 'A' ? *p - 'A' + 10 : *p - '0');
    *q = tmp;
  }
  *q = '\0';
  return sin;
}

void split (const char* s, char delim, std::vector <std::string>& ret) {
  ret.clear ();
  char s_[1024];
  std::strcpy (s_, s);
  decode_query (s_);
  std::stringstream ss (s_);
  std::string item;
  while (std::getline (ss, item, delim))
    if (!item.empty ())
      ret.push_back (item);
}

bool parseQS (char* s, std::vector <std::string>& q, size_t& max) {
  bool raw = false;
  char* qstr = getenv("QUERY_STRING");
  if (! qstr) return raw;
  char qs[BUFFER_SIZE];
  // parse query string
  std::strcpy (&qs[0],  qstr);
  for (char* p = std::strtok (qs, "&"); p != NULL; p = std::strtok (NULL, "&")) {
    if (std::strncmp (p, "q=", 2) == 0)
      split (p + 2, ',', q);
    else if (std::strncmp (p, "s=", 2) == 0)
      { std::strcpy (s, p + 2); decode_query (s); }
    else if (std::strncmp (p, "max=", 4) == 0)
      max = std::strtol (p + 4, NULL, 10);
  }
  return raw;
}

typedef cedar::da <int> trie_t;

struct triple_less {
  bool operator () (const trie_t::result_triple_type& a,
                    const trie_t::result_triple_type& b) const
  { return a.value > b.value; }
};

void read_dict (trie_t& trie, const char* dict)  {
  FILE* fp = ::fopen (dict, "r");
  for (char line[BUFFER_SIZE]; ::fgets (line, BUFFER_SIZE, fp) != NULL; ) {
    char* p = &line[0];
    while (*p != '\t') ++p;
    const size_t len = p - &line[0];
    const int    cnt = static_cast <int> (std::strtol (++p, NULL, 10));
    trie.update (&line[0], len) = cnt;
  }
  ::fclose (fp);
}

void read_hypo (std::tr1::unordered_map <std::string, std::vector <std::string> >& hypo2hypers,
                std::tr1::unordered_map <std::string, std::tr1::unordered_map <std::string, int> >& hyper2hypos,
                const char* dict)  {
  int i = 0;
  FILE* fp = ::fopen (dict, "r");
  for (char line[BUFFER_SIZE]; ::fgets (line, BUFFER_SIZE, fp) != NULL; ) {
    char* p     = &line[0];
    char* hyper = &line[0];
    while (*p != '\t') ++p; *p = '\0';
    char* hypo  = ++p;
    while (*p != '\t') ++p; *p = '\0';
    const int cnt = static_cast <int> (std::strtol (++p, NULL, 10));
    //
    std::tr1::unordered_map <std::string,
                             std::vector <std::string> >::iterator it =
      hypo2hypers.find (hypo);
    if (it == hypo2hypers.end ())
      it = hypo2hypers.insert (std::pair <std::string,
                                          std::vector <std::string> >
                               (hypo, std::vector <std::string> ())).first;
    it->second.push_back (hyper);
    //
    std::tr1::unordered_map <std::string,
                             std::tr1::unordered_map <std::string, int> >::iterator jt =
      hyper2hypos.find (hyper);
    if (jt == hyper2hypos.end ())
      jt = hyper2hypos.insert (std::pair <std::string,
                                          std::tr1::unordered_map <std::string, int> >
                               (hyper, std::tr1::unordered_map <std::string, int> ())).first;
    jt->second.insert (std::pair <std::string, int> (hypo, 0)).first->second += cnt;
  }
  ::fclose (fp);
}



int main (int argc, char** argv) {
  // read dictionary
  trie_t trie;
  read_dict (trie, DICT);
  //
  std::tr1::unordered_map <std::string, std::vector <std::string> > hypo2hypers;
  std::tr1::unordered_map <std::string, std::tr1::unordered_map <std::string, int> > hyper2hypos;
  read_hypo (hypo2hypers, hyper2hypos, HYPO);
  //
  char s[BUFFER_SIZE];
  std::strcpy (s, "");
  std::vector <std::string> q;
  size_t max = 30;
  trie_t::result_triple_type* result_triple = new trie_t::result_triple_type[NUM_RESULT];
#ifdef USE_FCGI
  while (FCGI_Accept() >= 0)
#else
  while (1)
#endif
    {
#ifdef USE_FCGI
      ::fprintf (stdout, "Content-type: text/html; charset=UTF-8\r\n\r\n");
#else
      ::fprintf (stderr, "synonyms> ");
      ::fgets (&s[0], BUFFER_SIZE, stdin);
      s[std::strlen (s) -1] = '\0';
      split (s, ',', q);
      ::fprintf (stderr, "prefix> ");
      ::fgets (&s[0], BUFFER_SIZE, stdin);
      s[std::strlen (s) -1] = '\0';
#endif
      // read query string
      bool raw = parseQS (&s[0], q, max);
      //
      if (const size_t n = trie.commonPrefixPredict (s, result_triple, NUM_RESULT)) {
        // ::fprintf (stdout, "%s\n", q);
        ::fprintf (stdout, "{\n");
        ::fprintf (stdout, "  \"items\": [\n");
        std::sort (&result_triple[0], &result_triple[n], triple_less ());
        size_t chosen = 0;
        for (size_t i = 0; i < n && chosen < max; ++i) {
          char suffix[BUFFER_SIZE];
          trie.suffix (suffix, result_triple[i].length, result_triple[i].id);
          std::string str (s); str += suffix;
          std::vector <std::string>& hypers = hypo2hypers[str];
          bool check = false;
          for (std::vector <std::string>::iterator it = hypers.begin ();
               it != hypers.end (); ++it) {
            check = true;
            for (std::vector <std::string>::iterator jt = q.begin ();
                 jt != q.end (); ++jt)
              check &= hyper2hypos[*it].find (*jt) != hyper2hypos[*it].end ();
            if (check) break;
          }
          if (check) {
            if (chosen)
              ::fprintf (stdout, "},\n");
            // ::fprintf (stdout, "%d:%s\n", result_triple[i].value, suffix);
            ::fprintf (stdout, "    {");
            ::fprintf (stdout, "\"id\": \"%s%s\", ", s, suffix);
            ::fprintf (stdout, "\"entity\": \"%s%s\", ", s, suffix);
            ::fprintf (stdout, "\"count\": %d", result_triple[i].value);
            ++chosen;
          }
        }
        if (chosen)
          ::fprintf (stdout, "}\n");
        ::fprintf (stdout, "  ]\n");
        ::fprintf (stdout, "}\n");
      }
    }
	delete [] result_triple;
  return 0;
}
